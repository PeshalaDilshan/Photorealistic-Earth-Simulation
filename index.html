<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photorealistic Earth Simulation with Rings, Stars, Moon, and GI</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/SSAOPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/shaders/CopyShader.js"></script>
    <script>
        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; // Enable shadow mapping
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for realism
        document.body.appendChild(renderer.domElement);

        // Post-processing for SSAO
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const ssaoPass = new THREE.SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
        ssaoPass.kernelRadius = 16;
        ssaoPass.minDistance = 0.005;
        ssaoPass.maxDistance = 0.1;
        composer.addPass(ssaoPass);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // OrbitControls for interactivity
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 10;

        // Load textures
        const textureLoader = new THREE.TextureLoader();
        const dayTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
        const nightTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_lights_2048.jpg');
        const specularMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_specular_2048.jpg');
        const normalMap = textureLoader.load('https://threejs.org/examples/textures/planets/earth_normal_2048.jpg');
        const cloudTexture = textureLoader.load('https://threejs.org/examples/textures/planets/earth_clouds_2048.jpg');
        const moonTexture = textureLoader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
        const moonNormalMap = textureLoader.load('https://threejs.org/examples/textures/planets/moon_normal_1024.jpg');
        // Ring texture (using a placeholder; replace with a high-res ring texture in production)
        const ringTexture = textureLoader.load('https://threejs.org/examples/textures/planets/saturn_ring_alpha.png');
        // Environment map for GI
        const envMap = new THREE.CubeTextureLoader().load([
            'https://threejs.org/examples/textures/cube/px.jpg',
            'https://threejs.org/examples/textures/cube/nx.jpg',
            'https://threejs.org/examples/textures/cube/py.jpg',
            'https://threejs.org/examples/textures/cube/ny.jpg',
            'https://threejs.org/examples/textures/cube/pz.jpg',
            'https://threejs.org/examples/textures/cube/nz.jpg'
        ]);
        scene.background = envMap;

        // Earth geometry and material
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        const earthMaterial = new THREE.MeshStandardMaterial({
            map: dayTexture,
            emissiveMap: nightTexture,
            emissive: new THREE.Color(0x444444),
            emissiveIntensity: 0.5,
            metalnessMap: specularMap,
            metalness: 0.5,
            roughness: 0.8,
            normalMap: normalMap,
            normalScale: new THREE.Vector2(0.5, 0.5),
            envMap: envMap,
            envMapIntensity: 0.3
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.castShadow = true;
        earth.receiveShadow = true;
        scene.add(earth);

        // Cloud layer
        const cloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
        const cloudMaterial = new THREE.MeshStandardMaterial({
            map: cloudTexture,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide,
            envMap: envMap,
            envMapIntensity: 0.2
        });
        const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
        clouds.castShadow = true;
        scene.add(clouds);

        // Moon geometry and material
        const moonGeometry = new THREE.SphereGeometry(0.27, 32, 32);
        const moonMaterial = new THREE.MeshStandardMaterial({
            map: moonTexture,
            normalMap: moonNormalMap,
            roughness: 1.0,
            metalness: 0.0,
            envMap: envMap,
            envMapIntensity: 0.3
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.castShadow = true;
        moon.receiveShadow = true;
        scene.add(moon);

        // Planetary rings
        const ringGeometry = new THREE.RingGeometry(1.2, 1.8, 64, 1);
        const ringMaterial = new THREE.MeshStandardMaterial({
            map: ringTexture,
            alphaMap: ringTexture,
            transparent: true,
            side: THREE.DoubleSide,
            roughness: 1.0,
            metalness: 0.0,
            envMap: envMap,
            envMapIntensity: 0.2
        });
        const rings = new THREE.Mesh(ringGeometry, ringMaterial);
        rings.rotation.x = Math.PI / 4; // Tilt rings for visual interest
        rings.castShadow = true;
        rings.receiveShadow = true;
        scene.add(rings);

        // Volumetric atmosphere shader
        const atmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
        const atmosphereShader = {
            uniforms: {
                time: { type: 'f', value: 0.0 },
                viewVector: { type: 'v3', value: camera.position },
                sunPosition: { type: 'v3', value: new THREE.Vector3(5, 3, 5) },
                planetRadius: { type: 'f', value: 1.0 },
                atmosphereRadius: { type: 'f', value: 1.05 },
                density: { type: 'f', value: 0.5 },
                scattering: { type: 'f', value: 0.02 },
                glowColor: { type: 'c', value: new THREE.Color(0x00bbff) }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 viewVector;
                uniform vec3 sunPosition;
                uniform float planetRadius;
                uniform float atmosphereRadius;
                uniform float density;
                uniform float scattering;
                uniform vec3 glowColor;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;

                float raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) {
                    vec3 s = s0 - r0;
                    float tca = dot(s, rd);
                    if (tca < 0.0) return -1.0;
                    float d2 = dot(s, s) - tca * tca;
                    float sr2 = sr * sr;
                    if (d2 > sr2) return -1.0;
                    float thc = sqrt(sr2 - d2);
                    return tca - thc;
                }

                float computeScattering(vec3 start, vec3 dir, vec3 sunDir, float t) {
                    float opticalDepth = 0.0;
                    const int steps = 8;
                    float stepSize = t / float(steps);
                    vec3 pos = start;
                    for (int i = 0; i < steps; i++) {
                        pos += dir * stepSize;
                        float height = length(pos) - planetRadius;
                        if (height < 0.0 || height > atmosphereRadius - planetRadius) continue;
                        float localDensity = exp(-height / (atmosphereRadius - planetRadius)) * density;
                        opticalDepth += localDensity * stepSize;
                    }
                    return exp(-opticalDepth * scattering);
                }

                void main() {
                    vec3 viewDir = normalize(viewVector - vWorldPosition);
                    vec3 sunDir = normalize(sunPosition - vWorldPosition);
                    float t = raySphereIntersect(vWorldPosition, viewDir, vec3(0.0), atmosphereRadius);
                    if (t < 0.0) discard;

                    vec3 start = vWorldPosition + viewDir * t;
                    float planetT = raySphereIntersect(vWorldPosition, viewDir, vec3(0.0), planetRadius);
                    float endT = planetT > 0.0 ? planetT - t : 1000.0;

                    float scatteringFactor = computeScattering(start, viewDir, sunDir, endT);
                    float intensity = pow(max(0.0, dot(vNormal, viewDir)), 2.0) * scatteringFactor;
                    vec3 color = glowColor * intensity * (1.0 - exp(-endT * 0.01));

                    gl_FragColor = vec4(color, intensity * 0.5);
                }
            `
        };
        const atmosphereMaterial = new THREE.ShaderMaterial({
            uniforms: atmosphereShader.uniforms,
            vertexShader: atmosphereShader.vertexShader,
            fragmentShader: atmosphereShader.fragmentShader,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);

        // Procedural starfield
        const starCount = 5000;
        const starGeometry = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 50 + Math.random() * 10;
            starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPositions[i * 3 + 2] = r * Math.cos(phi);
            const brightness = 0.5 + Math.random() * 0.5;
            starColors[i * 3] = brightness;
            starColors[i * 3 + 1] = brightness;
            starColors[i * 3 + 2] = brightness * 0.9;
        }
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        const starMaterial = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(5, 3, 5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.1;
        sunLight.shadow.camera.far = 20;
        sunLight.shadow.camera.left = -5;
        sunLight.shadow.camera.right = 5;
        sunLight.shadow.camera.top = 5;
        sunLight.shadow.camera.bottom = -5;
        scene.add(sunLight);
        const ambientLight = new THREE.AmbientLight(0x222222, 0.2);
        scene.add(ambientLight);
        const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x1e2f3e, 0.3);
        scene.add(hemiLight);

        // Position camera
        camera.position.set(0, 0, 3);

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Rotate Earth, clouds, and rings
            earth.rotation.y += 0.001;
            clouds.rotation.y += 0.0015;
            rings.rotation.y += 0.0005; // Slower rotation for rings

            // Orbit Moon
            time += 0.01;
            moon.position.set(Math.cos(time * 0.05) * 2.5, 0, Math.sin(time * 0.05) * 2.5);

            // Update atmosphere uniforms
            atmosphereMaterial.uniforms.time.value = time;
            atmosphereMaterial.uniforms.viewVector.value = camera.position;

            // Update controls
            controls.update();

            // Render scene with post-processing
            composer.render();
        }
        animate();
    </script>
</body>
</html>
